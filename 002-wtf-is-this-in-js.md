# WTF is "this" in Javascript

That topic we should all have learnt straight off the bat but that, for whatever reason, we decided to skip without fully understand it... I know, I am one of you.

## TL;DR

The `this` keyword in Javascript, simply put, references an object. What is tricky is that the object, whose `this` references to, can vary depending on the execution context... and that makes it a confusing topic.

## What is `this`

The `this` keyword in Javascript, simply put, references an object. Which object? It depends on the context in which `this` is called. Please remember that the `this` keyword cannot be set by assignment during the execution of a function. Its value is intrinsically given depending on the execution context.

> NOTE: The `bind()` method was introduced to allow the developer to set the value of a function's `this` regardless of how it's called. In addition, arrow functions were later introduced as well. They don't provide their own `this` binding as they maintain the value of `this` from the enclosing lexical context. More about it later.

[MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this) defines `this` as follow:

> A property of an execution context (global, function or eval) that, in non–strict mode, is always a reference to an object and in strict mode can be any value.

Let's unpack it... shall we?

## What is an execution context?

The execution context is the environment in which a function is executed. Depending on the environment your code will have access to a specific number of *variables*, *objects*, *functions*, etc.

As per the definition you saw above, there are three possible execution context in Javascript:

- the **global execution context** - there can be only one and it is the default execution context for Javascript code;

- the **functional execution context** - there can be many, they are generated by the Javascript engine whenever a function call is executed;

- the **eval execution context** - the execution context inside an `eval()` function.

## Let's get our hands a bit dirty

First and foremost, I will not talk about the *eval* execution context. You may ask why? The answer is simple... because you should never ever use `eval()`. Therefore, there is no point talking about it. If you do not believe me, learn why for yourself [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval).

With that out of the way, let's focus on functions and the global object. (Btw, in Javascript, [functions are objects](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions). Therefore, whether we talk about one or the other, we are always talking about objects).

### Implicit binding

#### Functions in the global execution context

For a regular function, called in the global context the `this` keyword will reference the global object itself.

The global object is `window` (browsers) and `global` (node).

> NOTE: You can get the global object from whatever context your code is in just using the global `globalThis` property.

````js
function showThis() {
    console.log(this);
}

showThis(); // Window { ... }
````

#### Functions as a method of an object

If the function is part of an object (or part of a class) we call it a **method** and the `this` keyword references the object itself.

````js
const book = {
    title: "Title",
    read: function() {
        console.log(this);
    }
};

// also when introducing methods later
book.stop = function() {
    console.log(this);
}

book.read(); // {title: "Title", play: f, stop: f}
book.stop(); // {title: "Title", play: f, stop: f}
````

We can also speak about implicit binding when, using the dot-notation, a function is invoked immediately after its object (`book.read()` example above).

#### Functions as constructor functions or class constructors - `new` keyword

If the function is a constructor function (or a class constructor), the `this` keyword will reference the object the function is constructing.

To call a constructor function (or create a new instance of an object from a class), we need to use the `new` keyword. This will create a new empty object (`{}`), the value of `this` will be implicitely given reference to that object.

````js
// constructor functions are conventionally capitalised

function Movie(title) {
    this.title = title;
    console.log(this);
}

const movie = new Movie("Title"); // Movie {title: "Title"}

// same story for a class

class User {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    getAge() {
        console.log(`${this.name} is ${this.age} years old`);
    }
}

const bob = new User("Bob", 36);
bob.getAge(); // Bob is 36 years old
````

### Explicit binding

#### Explicit binding with `call()`, `apply()` and `bind()`

You can set the value of `this` to a particular value when calling a function, in strict mode or non-strict mode, using `call()`, or `apply()` as in the examples below.

````js
var obj = { key: "A" };
var key = "B";

function whatIsThis() {
    console.log(this.key);
}

whatIsThis(); // "B"
whatIsThis.call(obj); // "A"
whatIsThis.apply(obj); // "A"
````

In non–strict mode, with `call()` and `apply()`, if the value passed as `this` is not an object, an attempt will be made to convert it to an object.

````js
function foo() {
    console.log(this);
}

foo.apply("C"); // String {'C'}
foo.apply(9); // Number {9}
````

In Javascript there is a way to `bind()` an object to a function. The binding is permanent, regardless of how the function is being used. The difference between `bind()` and `call()` and `apply()` is that the `bind()` returns a brand new function that can be directly invoked.

````js
function func() {
    console.log(this.key);
}

var obj1 = { key: "A" };
var obj2 = { key: "Z" };

var bindedfunc = func.bind(obj1);
bindedfunc(); // A

var secondBinding = bindedfunc.bind(obj2);
secondBinding(); // A
````

### Functions VS Arrow functions

Arrow functions were a later introduction in the Javascript world. Their syntax is certainly very sleek and slender but they are not only a language embellishment as they bring some additional characteristics to the table.

This is not the place to discuss of arrow functions in depth, but they are meaningful in the way the `this` keyword is managed.

In arrow functions, the `this` keyword keep the value of the enclosing context. As a consequence, it does not make any sense to `bind()`, `call()` or `apply()` an arrow function as the value of `this` depends only on where the arrow function is called.

````js

// #1 - the function context is NOT the same as the object context
const movie = {
    title: "A movie",
    tags: ["#mustsee", "#bestever", "#donotmissit"],
    showTags() {
        this.tags.forEach(function(tag) {
            console.log(`${this.title} + ${tag}`);
        });
    }
};

movie.showTags(); 
//undefined + #mustsee
//undefined + #bestever
//undefined + #donotmissit

// #2 - we use the "thisArg" (equivalent to bind()) of the forEach callback function to bind the object and being able to access the title property
const movie2 = {
    title: "A movie2",
    tags: ["#mustsee", "#bestever", "#donotmissit"],
    showTags() {
        this.tags.forEach(function(tag) {
            console.log(`${this.title} + ${tag}`);
        }, this); // forEach takes a second parameter "thisArg" - equivalent to bind()
    }
};

movie2.showTags(); 
//A movie2 + #mustsee
//A movie2 + #bestever
//A movie2 + #donotmissit

// #3 - we use arrow functions - no binding required
const movie3 = {
    title: "A movie3",
    tags: ["#mustsee", "#bestever", "#donotmissit"],
    showTags() {
        this.tags.forEach((tag) => {
            console.log(`${this.title} + ${tag}`);
        });
    }
};

movie3.showTags(); 
//A movie3 + #mustsee
//A movie3 + #bestever
//A movie3 + #donotmissit
````

### Functions in `strict mode`

What happens when a function is executed in `strict mode`? Well, in this case the `this` keyword can have any value and, if no value is set, the value would be `undefined`.

````js
function strickty() {
  'use strict';
  return this;
}

console.log(strickty()); // undefined 
````

### HTML event element binding

There is a special `this` context for DOM event handlers. Normally, after creating a DOM element and registering an event listener to it, we would receive back the `event` data. The `event` data can be used to reference the DOM element itself by calling `event.target`. An equivalent way to achieve that would be to use the `this` keyword, as shown below by the code snippet.

````js
const button = document.createElement("button");
button.textContent = "Click";
document.body.appendChild(button);

button.addEventListener("click", function(event) {
    console.log(this); // <button>Click</button>
    console.log(event.target); // <button>Click</button>
})
````

There are use cases when we may want to use strict mode. For example, when we do not want to have data, scoped to a function, to leak in the outer scope. In addition, it may be worth "protect" the global object from potential manipulations.

## In summary

- The `this` keyword in Javascript references an object. The object it references depends on the execution context.

- The `this` keyword can be binded to an object implicitely or explicitely.

  - We say the object is implicitely binded in the case of functions in the global context, functions as methods of objects or classes and construction functions or class constructors (due to the `new` keyword).

  - We say the object is explicitely binded in case a `call()`, `apply()` or `bind()` method is called on a function. In this case, the programmer can bind to the function itself any object.

- Arrow functions behave differently from regular functions as there is no binding. The value of `this` is retained from the enclosing context.

- When in strict mode, the value of `this`, unless assigned, will be always `undefined`.

- When adding an event listener to a DOM element in Javascript, the `this` value in the event listener callback function is the DOM element itself.
